import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  Alert,
  RefreshControl,
  SafeAreaView,
  Platform
} from 'react-native';
import { darkColors, spacing, typography, createThemedStyles } from '../../theme/theme';
import SkeletonQuizItem from '../../components/SkeletonQuizItem';
import { Stack, useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { getUserQuizzes, deleteQuiz } from '../../services/quizService';
import { useNetwork } from '../../contexts/NetworkContext';
import NetworkStatusBar from '../../components/NetworkStatusBar';
import logger from '../../services/loggerService';
import { useAuth } from '../../contexts/AuthContext'; // Import useAuth

const PAGE_LIMIT = 10;

const QuizzesScreen = () => {
  const router = useRouter();
  const { session } = useAuth(); // Get session from AuthContext
  const [quizzes, setQuizzes] = useState([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalQuizzes, setTotalQuizzes] = useState(0);
  const [isLoadingInitial, setIsLoadingInitial] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [error, setError] = useState(null);
  const { isConnected } = useNetwork();

  const fetchQuizzes = useCallback(async (pageToFetch = 1, refreshing = false) => {
    if (!session) {
      logger.info('QuizzesScreen', 'No session, skipping quiz fetch');
      setQuizzes([]);
      setTotalQuizzes(0);
      setCurrentPage(1);
      setIsLoadingInitial(false);
      setIsRefreshing(false);
      setIsLoadingMore(false);
      setError(null);
      return;
    }

    logger.info('QuizzesScreen', `Fetching quizzes, page: ${pageToFetch}`, { refreshing, isOffline: !isConnected });
    setError(null);

    if (pageToFetch === 1 && !refreshing) {
      setIsLoadingInitial(true);
    } else if (pageToFetch > 1) {
      setIsLoadingMore(true);
    }
    if (refreshing) {
      setIsRefreshing(true);
    }

    try {
      const { quizzes: newQuizzes, totalCount } = await getUserQuizzes(pageToFetch, PAGE_LIMIT);
      
      if (pageToFetch === 1) {
        setQuizzes(Array.isArray(newQuizzes) ? newQuizzes : []);
      } else {
        setQuizzes(prevQuizzes => [...prevQuizzes, ...(Array.isArray(newQuizzes) ? newQuizzes : [])]);
      }
      setTotalQuizzes(totalCount || 0);
      setCurrentPage(pageToFetch);
      logger.info('QuizzesScreen', `Fetched ${newQuizzes?.length || 0} new quizzes. Total in list: ${pageToFetch === 1 ? newQuizzes?.length || 0 : quizzes.length + (newQuizzes?.length || 0)}. Total available: ${totalCount || 0}.`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error('QuizzesScreen', 'Error fetching quizzes', { error: errorMessage, page: pageToFetch, isOffline: !isConnected });
      setError('Failed to load exams. Please try again.');
      // If it's the first page load and it fails, clear existing quizzes
      if (pageToFetch === 1) {
        setQuizzes([]);
        setTotalQuizzes(0);
      }
    } finally {
      if (pageToFetch === 1 && !refreshing) {
        setIsLoadingInitial(false);
      }
      if (pageToFetch > 1) {
        setIsLoadingMore(false);
      }
      if (refreshing) {
        setIsRefreshing(false);
      }
    }
  }, [session, isConnected]); // Added session and isConnected as dependencies

  useEffect(() => {
    // Initial fetch when component mounts or session changes
    if (session) {
      fetchQuizzes(1);
    }
    // If no session, fetchQuizzes will handle clearing state
  }, [session, fetchQuizzes]);

  const handleRefresh = () => {
    logger.info('QuizzesScreen', 'Refreshing quizzes...');
    setCurrentPage(1); // Reset page for refresh
    fetchQuizzes(1, true); 
  };

  const handleLoadMore = () => {
    if (isLoadingMore || quizzes.length >= totalQuizzes) {
      if (quizzes.length >= totalQuizzes && totalQuizzes > 0) {
        logger.info('QuizzesScreen', "You've reached the end of your exams.", { nextPage: currentPage + 1 });
      }
      return;
    }
    logger.info('QuizzesScreen', 'Loading more quizzes...', { nextPage: currentPage + 1 });
    fetchQuizzes(currentPage + 1);
  };

  const handleStartQuiz = (quiz) => {
    router.push(`/quiz/${quiz.id}`);
  };

  const performActualDelete = async (quizId, quizTitle) => {
    try {
      await deleteQuiz(quizId);
      // Optimistically remove from UI and then refresh to get the true state from backend
      // This handles cases where quiz order might change or count is affected
      setQuizzes(prevQuizzes => prevQuizzes.filter(quiz => quiz.id !== quizId));
      setTotalQuizzes(prevTotal => prevTotal > 0 ? prevTotal - 1 : 0);
      
      logger.info('QuizzesScreen', `Quiz deleted: ${quizId} ("${quizTitle}")`, { isOffline: !isConnected });
      
      // Optionally, could trigger a refresh if exact count from server is critical post-delete
      // handleRefresh(); // Or fetchQuizzes(1); to ensure list is accurate after delete
      // For now, optimistic update is fine, pagination handles eventual consistency.

      if (!isConnected) {
        const message = 'Exam marked for deletion. It will be permanently deleted when you reconnect to the internet.';
        if (Platform.OS === 'web') {
          console.log(`Offline Mode (Quiz Deletion: ${quizTitle}): ${message}`);
        } else {
          Alert.alert('Offline Mode', message, [{ text: 'OK' }]);
        }
      }
    } catch (err) {
      const errorMessage = `Failed to delete exam "${quizTitle}". Please try again.`;
      logger.error('QuizzesScreen', `Error deleting quiz: ${quizId} ("${quizTitle}")`, err);
      // Re-fetch to ensure UI consistency if delete failed
      handleRefresh(); 
      if (Platform.OS === 'web') {
        console.error(`Error deleting quiz "${quizTitle}": ${err.message}`);
        //setError(errorMessage); // Alert is more prominent for critical actions
        Alert.alert('Error', errorMessage);
      } else {
        Alert.alert('Error', errorMessage);
      }
    }
  };

  const handleDeleteQuiz = (quizId, quizTitle) => {
    if (Platform.OS === 'web') {
      // TODO: Implement custom web confirmation modal for quiz deletion.
      if (window.confirm(`Are you sure you want to delete "${quizTitle}"?`)) {
        performActualDelete(quizId, quizTitle);
      }
    } else {
      Alert.alert(
        'Delete Exam',
        `Are you sure you want to delete "${quizTitle}"?`,
        [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'Delete',
            style: 'destructive',
            onPress: () => performActualDelete(quizId, quizTitle)
          }
        ],
        { cancelable: true }
      );
    }
  };

  const renderQuizItem = ({ item }) => (
    <View style={styles.quizItem}>
      <View style={styles.quizInfo}>
        <Text style={styles.quizTitle}>
          {item.title}
          {item.is_cached && (
            <Text style={styles.cachedBadge}> (Available Offline)</Text>
          )}
        </Text>
        <Text style={styles.quizDetails}>
          {item.question_count || 'N/A'} questions â€¢ Created on {new Date(item.created_at).toLocaleDateString()}
        </Text>
      </View>
      
      <View style={styles.quizActions}>
        <TouchableOpacity 
          style={styles.startButton}
          onPress={() => handleStartQuiz(item)}
        >
          <Text style={styles.startButtonText}>Start</Text>
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.deleteButton}
          onPress={() => handleDeleteQuiz(item.id, item.title)}
          // Deletion should always be possible if the item is visible
          // Offline handling for delete is in performActualDelete
        >
          <Ionicons 
            name="trash-outline" 
            size={20} 
            color={'#A0AEC0'} 
          />
        </TouchableOpacity>
      </View>
    </View>
  );

  const renderFooter = () => {
    if (!isLoadingMore) return null;
    return (
      <View style={styles.footerLoadingContainer}>
        <ActivityIndicator size="large" color="#FFFFFF" />
      </View>
    );
  };

  const renderEmptyState = () => {
    // Show empty state if not loading initial, no error, and no quizzes after fetch attempt
    if (isLoadingInitial || error) return null; 
    if (quizzes.length > 0) return null; // Already have quizzes

    return (
      <View style={styles.emptyContainer}>
        <Ionicons name="document-text-outline" size={64} color="#9CA3AF" />
        <Text style={styles.emptyText}>No exams found.</Text>
        <Text style={styles.emptySubtext}>
          {session 
            ? (isConnected ? 'Generate a new exam from your documents on the Home screen.' : 'Exams may be available offline. Try refreshing or check your connection.')
            : 'Please log in to see your exams.'}
        </Text>
        {session && isConnected && (
          <TouchableOpacity 
            style={styles.generateButton}
            onPress={() => router.push('/(tabs)/generate-quiz')} // Updated path
          >
            <Text style={styles.generateButtonText}>Generate Quiz</Text>
          </TouchableOpacity>
        )}
        {!session && (
           <TouchableOpacity 
            style={styles.generateButton} // Re-use style, or make a new one
            onPress={() => router.push('/(auth)/sign-in')} // Navigate to sign-in
          >
            <Text style={styles.generateButtonText}>Log In</Text>
          </TouchableOpacity>
        )}
      </View>
    );
  };

  // Render skeleton loading UI instead of full-screen loading indicator
  const renderSkeletonLoading = () => {
    return Array(5).fill(0).map((_, index) => (
      <SkeletonQuizItem key={`skeleton-${index}`} />
    ));
  };

  if (error && quizzes.length === 0) { // Show full screen error only if no quizzes are displayed
    return (
      <SafeAreaView style={styles.container}>
        <Stack.Screen options={{ title: 'My Exams' }} />
        <NetworkStatusBar />
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle" size={48} color="#EF4444" />
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity style={styles.retryButton} onPress={handleRefresh}>
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }
  
  return (
    <SafeAreaView style={styles.container}>
      <Stack.Screen options={{ title: 'My Exams' }} />
      <NetworkStatusBar />
      
      {!isConnected && (
        <View style={styles.offlineMessage}>
          <Ionicons name="cloud-offline-outline" size={20} color="#3B82F6" />
          <Text style={styles.offlineMessageText}>
            You're offline. Showing cached quizzes. Some actions may be queued.
          </Text>
        </View>
      )}
       {/* Display error as a banner if there are already quizzes loaded */} 
      {error && quizzes.length > 0 && (
        <View style={styles.errorBanner}>
            <Ionicons name="warning-outline" size={20} color="#F5C5C5" />
            <Text style={styles.errorBannerText}>{error} Please try refreshing.</Text>
        </View>
      )}

      {isLoadingInitial && quizzes.length === 0 ? (
        <View style={styles.listContent}>
          {renderSkeletonLoading()}
        </View>
      ) : (
        <FlatList
          data={quizzes}
          renderItem={renderQuizItem}
          keyExtractor={(item, index) => `${item.id.toString()}-${index}`}
          contentContainerStyle={quizzes.length === 0 ? styles.emptyFlatList : styles.listContent}
          ListEmptyComponent={!isLoadingInitial ? renderEmptyState : null}
          ListFooterComponent={renderFooter}
          onEndReached={handleLoadMore}
          onEndReachedThreshold={0.5}
          
          // FlatList optimization props
          removeClippedSubviews={true}
          initialNumToRender={5}
          maxToRenderPerBatch={10}
          windowSize={10}
          updateCellsBatchingPeriod={50}
          
          refreshControl={
            <RefreshControl 
              refreshing={isRefreshing} 
              onRefresh={handleRefresh} 
              colors={['#8dffd6']} // Android spinner color (accent)
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: theme.spacing.l,
    backgroundColor: theme.colors.background,
  },
  errorText: {
    fontSize: theme.typography.body.fontSize + 2,
    color: theme.colors.error,
    textAlign: 'center',
    marginBottom: theme.spacing.m,
  },
  retryButton: {
    backgroundColor: theme.colors.primary,
    paddingVertical: theme.spacing.s,
    paddingHorizontal: theme.spacing.xl - 2,
    borderRadius: 8,
    marginTop: theme.spacing.xs,
  },
  retryButtonText: {
    color: theme.colors.primaryContent,
    fontSize: theme.typography.body.fontSize,
    fontWeight: '600',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: theme.spacing.l,
    marginTop: 50, // Keep existing margin
    backgroundColor: theme.colors.background,
  },
  emptyText: {
    fontSize: theme.typography.h3.fontSize,
    fontWeight: theme.typography.h3.fontWeight,
    color: theme.colors.text,
    textAlign: 'center',
    marginTop: theme.spacing.m,
  },
  emptySubtext: {
    fontSize: theme.typography.caption.fontSize + 2,
    color: theme.colors.subtext,
    textAlign: 'center',
    marginTop: theme.spacing.xs,
    marginBottom: theme.spacing.l,
    lineHeight: 20,
  },
  generateButton: {
    backgroundColor: theme.colors.primary,
    paddingVertical: theme.spacing.s,
    paddingHorizontal: theme.spacing.l,
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
  },
  generateButtonText: {
    color: theme.colors.primaryContent,
    fontSize: theme.typography.body.fontSize,
    fontWeight: '600',
    marginLeft: theme.spacing.xs,
  },
  quizItem: {
    backgroundColor: theme.colors.surface,
    padding: theme.spacing.m,
    marginVertical: theme.spacing.xs,
    marginHorizontal: theme.spacing.m,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: theme.colors.border,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  quizInfo: {
    flex: 1,
    marginRight: theme.spacing.xs + 2,
  },
  quizTitle: {
    fontSize: 17,
    fontWeight: '600',
    color: theme.colors.text,
    marginBottom: 4,
  },
  quizDetails: {
    fontSize: theme.typography.caption.fontSize + 1,
    color: theme.colors.subtext,
  },
  cachedBadge: {
    fontSize: theme.typography.caption.fontSize,
    color: theme.colors.subtext,
    fontWeight: '500',
  },
  quizActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  startButton: {
    backgroundColor: theme.colors.primary,
    paddingVertical: theme.spacing.xs + 2,
    paddingHorizontal: theme.spacing.m,
    borderRadius: 6,
    marginLeft: theme.spacing.xs,
  },
  startButtonText: {
    color: theme.colors.primaryContent,
    fontWeight: '600',
    fontSize: 14,
  },
  deleteButton: {
    padding: theme.spacing.xs,
    borderRadius: 6,
  },
  listContent: {
    paddingBottom: theme.spacing.l,
  },
  emptyFlatList: {
    flexGrow: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  footerLoadingContainer: {
    paddingVertical: theme.spacing.l,
    alignItems: 'center',
    justifyContent: 'center',
  },
  offlineMessage: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(59, 130, 246, 0.1)', // Light blue with opacity
    paddingVertical: theme.spacing.xs,
    paddingHorizontal: theme.spacing.m,
    marginBottom: theme.spacing.xs + 2,
  },
  offlineMessageText: {
    color: '#3B82F6', // Blue text
    marginLeft: theme.spacing.xs,
    fontSize: theme.typography.caption.fontSize + 2,
  },
  errorBanner: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(239, 68, 68, 0.1)', // Light red with opacity
    paddingVertical: theme.spacing.xs,
    paddingHorizontal: theme.spacing.m,
    marginBottom: theme.spacing.xs + 2,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#693030', // Slightly lighter dark red
  },
  errorBannerText: {
    marginLeft: 8,
    fontSize: 14,
    color: '#F5C5C5', // Light red text
  },
});

export default QuizzesScreen;
